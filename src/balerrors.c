/*
 * balerrors.c
 *
 * Author:    Ryan M. Lederman <lederman@gmail.com>
 * Copyright: Copyright (c) 2004-2023
 * Version:   0.2.0
 * License:   The MIT License (MIT)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of
 * this software and associated documentation files (the "Software"), to deal in
 * the Software without restriction, including without limitation the rights to
 * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
 * the Software, and to permit persons to whom the Software is furnished to do so,
 * subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
 * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
 * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
 * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */
#include "bal.h"
#include "bal/errors.h"
#include "bal/internal.h"

#if defined(__WIN__)
# pragma comment(lib, "shlwapi.lib")
#endif

/** Container for information about the last error that occurred on this thread. */
static _bal_thread_local bal_error_info _error_info = {
    0, BAL_UNKNOWN, BAL_UNKNOWN, 0U, false
};

/** The format string used to format error messages generated by libbal when
 * extended information (function, file, line) is requested. */
static const char* const BAL_ERRFMTEXT = "Error in %s (%s:%u): '%s'";

/** The format string used to format error messages generated by libbal when
 * extended information is not requested. */
static const char* const BAL_ERRFMT = "%s";

/** The format sting used when the error is not from libbal itself, but rather a
 * lower layer, such as libc. */
static const char* const BAL_ERRFMTPFORM = "Platform error %d: %s";

/** Map of defined libbal-specific packed error code values <-> descriptions. */
static const struct {
    const int code;
    const char* const desc;
} bal_error_dict[] = {
    {_BAL_E_NULLPTR,    "NULL pointer argument"},
    {_BAL_E_BADSTRING,  "Invalid string argument"},
    {_BAL_E_BADSOCKET,  "Invalid bal_socket argument"},
    {_BAL_E_BADBUFLEN,  "Invalid buffer length argument"},
    {_BAL_E_INVALIDARG, "Invalid argument"},
    {_BAL_E_NOTINIT,    "libbal is not initialized"},
    {_BAL_E_DUPEINIT,   "libbal is already initialized"},
    {_BAL_E_ASNOTINIT,  "Asynchronous I/O is not initialized"},
    {_BAL_E_ASDUPEINIT, "Asynchronous I/O is already initialized"},
    {_BAL_E_ASNOSOCKET, "Socket is not registered for asynchronous I/O events"},
    {_BAL_E_BADEVTMASK, "Invalid asynchronous I/O event bitmask"},
    {_BAL_E_INTERNAL,   "An internal error has occurred"},
    {_BAL_E_UNAVAIL,    "Feature is disabled or unavailable"}
};

int _bal_get_last_error(bal_error* err, bool extended)
{
    int retval = 0;

    if (_bal_validptr(err)) {
        memset(err, 0, sizeof(bal_error));
        err->code = _error_info.code;
        _bal_formaterrormsg(err, _error_info.gai, extended);
        retval = err->code;
    }

    return retval;
}

bool __bal_setlasterror(int code, const char* func, const char* file,
    uint32_t line, bool gai)
{
    _error_info.code = code;
    _error_info.func = func;
    _error_info.file = file;
    _error_info.line = line;
    _error_info.gai  = gai;

#if defined(BAL_DBGLOG) && defined(BAL_DBGLOG_SETERROR)
    bal_error err = {0};
    __bal_dbglog(func, file, line, "set last error to %d (%s)",
        _bal_get_last_error(&err, false), err.desc);
#endif
    return false;
}

void _bal_formaterrormsg(bal_error* err, bool gai, bool extended)
{
    if (!_bal_validptr(err))
        return;

    char raw_msg[BAL_MAXERROR] = {0};
    if (!_bal_is_error(err->code)) {
        /* not a libbal-specific error; format message from platform. */
#if defined(__WIN__)
        BAL_UNUSED(gai);

        DWORD flags = FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS |
                      FORMAT_MESSAGE_MAX_WIDTH_MASK;
        DWORD fmt = FormatMessageA(flags, NULL, (DWORD)err->code, 0UL, raw_msg,
            BAL_MAXERROR, NULL);

        assert(0UL != fmt);
        if (fmt > 0UL) {
            if (raw_msg[fmt - 1] == '\n' || raw_msg[fmt - 1] == ' ')
                raw_msg[fmt - 1] = '\0';
        }
#else
        if (gai) {
            const char* tmp = gai_strerror(err->code);
            _bal_strcpy(raw_msg, BAL_MAXERROR, tmp, strnlen(tmp, BAL_MAXERROR));
        } else {
            int finderr = -1;
# if defined(__HAVE_XSI_STRERROR_R__)
            finderr = strerror_r(err->code, raw_msg, BAL_MAXERROR);
#  if defined(__HAVE_XSI_STRERROR_R_ERRNO__)
            if (finderr == -1)
                finderr = errno;
#  endif
# elif defined(__HAVE_GNU_STRERROR_R__)
            char* tmp = strerror_r(err->code, raw_msg, BAL_MAXERROR);
            if (tmp != raw_msg)
                _bal_strcpy(raw_msg, BAL_MAXERROR, tmp, strnlen(tmp, BAL_MAXERROR));
# elif defined(__HAVE_STRERROR_S__)
            finderr = (int)strerror_s(raw_msg, BAL_MAXERROR, err->code);
# else
            char* tmp = strerror(err->code);
            _bal_strcpy(raw_msg, BAL_MAXERROR, tmp, strnlen(tmp, BAL_MAXERROR));
# endif
# if defined(__HAVE_XSI_STRERROR_R__) || defined(__HAVE_STRERROR_S__)
            assert(0 == finderr);
# endif
            BAL_UNUSED(finderr);
        }
#endif
        char pform_msg[BAL_MAXERROR] = {0};
        size_t raw_msg_len = strnlen(raw_msg, BAL_MAXERROR);
        
        (void)snprintf(pform_msg, BAL_MAXERROR - raw_msg_len, BAL_ERRFMTPFORM,
            err->code, raw_msg);

        size_t pform_msg_len = strnlen(pform_msg, BAL_MAXERROR);
        if (extended) {
            (void)snprintf(err->desc, BAL_MAXERROR - pform_msg_len, BAL_ERRFMTEXT,
                _error_info.func, _error_info.file, _error_info.line, pform_msg);
        } else {
            (void)snprintf(err->desc, BAL_MAXERROR - pform_msg_len, BAL_ERRFMT,
                pform_msg);
        }
    } else {
        /* a libbal-specific error. */
        bool found = false;
        for (size_t n = 0UL; n < _bal_countof(bal_error_dict); n++) {
            if (bal_error_dict[n].code == err->code) {
                found = true;
                err->code = _bal_err_code(err->code);
                if (extended) {
                    (void)snprintf(err->desc, BAL_MAXERROR, BAL_ERRFMTEXT,
                        _error_info.func, _error_info.file, _error_info.line,
                        bal_error_dict[n].desc);
                } else {
                    (void)snprintf(err->desc, BAL_MAXERROR, BAL_ERRFMT,
                        bal_error_dict[n].desc);
                }
                break;
            }
        }
        assert(found);
    }
}

#if defined(BAL_DBGLOG)
void __bal_dbglog(const char* func, const char* file, uint32_t line,
    const char* format, ...)
{
    va_list args;
    va_list args2;
    va_start(args, format);
    va_copy(args2, args);

    int prnt_len = vsnprintf(NULL, 0, format, args);

    va_end(args);
    BAL_ASSERT(prnt_len > 0);

    char* buf = calloc(prnt_len + 1, sizeof(char));
    BAL_ASSERT(NULL != buf);

    if (buf) {
        char prefix[256] = {0};
        int len = snprintf(prefix, 256, "["BAL_TID_SPEC"] %s (%s:%"PRIu32"): ",
            _bal_gettid(), func, file, line);
        BAL_ASSERT_UNUSED(len, len > 0 && len < 256);

        (void)vsnprintf(buf, prnt_len + 1, format, args2);
        va_end(args2);

        const char* color = "0";
# if defined(__WIN__)
        if (NULL != StrStrIA(buf, "error") || NULL != StrStrIA(buf, "assert"))
            color = "91";
        else if (NULL != StrStrIA(buf, "warn"))
            color = "33";
# else
        if (NULL != strcasestr(buf, "error") || NULL != strcasestr(buf, "assert"))
            color = "91";
        else if (NULL != strcasestr(buf, "warn"))
            color = "33";
# endif
        printf("\x1b[%sm%s%s\x1b[0m\n", color, prefix, buf);

        _bal_safefree(&buf);
    }
}
#endif
